# C

The C Programming Language - Brian W. Kernighan and Dennis M. Ritchie

## Chpaters 1-4

It is interesting that the author chooses to introduce compilations, functions, and arguments so early in the textbook.  Does the compiler have to read through all of the text in the comments or does it know to skip to the end of a comment?  Since a 32 bit int has more memory can it store a larger range of numbers?  I never realized how general-purpose printf was.  It is impressive that it can match %d to the other arguments in the function call.  What is the ANSI standard?  I never knew that if you do an operation with a float and an int, the int will be converted to a float before the operation.  I’ve never used the notation for printing floats.  It looks nice to be able to specify the precision in the printf argument and not somewhere else in the program like I’ve done in 281.  I do not understand when they said use %% for recognizing itself.  Section 1.3 is a good reminder that a for loop is just a while loop under the hood.  I like the #define feature of c.  It seems useful for someone reading the code.  Also are the #define variables constant?  I never really knew what a text stream was.  So is EOF a symbolic constant?  Why is ++nc more efficient than nc = nc + 1?  I never knew you could use an isolated semicolon (null statement) for the body of a for loop.  I like how the author mentions the fact that || and && stop once an expression is true or false respectively.  Section 1.6 really illustrates how characters and digits are just numbers in a character table.  Section 1.7 is a good reminder that we do not have to understand the implementation of functions.  Wouldn’t it be better to return a long in the power function since exponentials can get large very quickly.  I never knew formal argument and actual argument were other names for function parameters.  I did not know that the term for putting a function at the top of a file with no definition is called a function prototype.  I also did not know that parameter names are optional in the function prototype.  C looks like nice in the fact that variables are automatically passed by value and that you also have the ability to pass data structures by reference.  Section 1.9 brings up a good point that as programs get more complicated error handling is necessary.  I never knew local variables could be referred to as automatic variables. What are the disadvantages to using external (global) variables?  Section 1.10 is a good reminder for why we use header files.  I did not know that you needed void in parentheses for a function prototype if the function does not take any arguments.  Not that I start my variable names with underscores, but I did not realise that was bad practice.  Section 2.1 is a good reminder of naming conventions.  I did not realise that long was shorthand for long int.  I did not know that an unsigned int could hold a greater range of positive values compared to a signed int.  I never realized that you could change constants the way that section 2.3 describes with terminating letters and such.  I didn’t know you could specify arbitrary byte-sized bit patterns.  I didn’t know that you could specify the values for an enum.  I never knew external and static variables are set equal to 0 by default.  What is an underflow?  Section 2.6 is a good reminder that some operators have different precedences.  It is interesting that converting chars to ints varies so much from machine to machine.  Good reminder that any non-zero value is evaluated to true.  I did not realise type conversions got so tricky when working with unsigned and signed data types.  I didn’t know that type conversion also takes place when passing arguments.  Section 2.8 is a good reminder on how we can write more concise code with the postfix increment or decrement.  I did not realise there was a bitwise exclusive or.  I didn’t realise all of the different assignment operators that exist in C.  The ternary operator ? can really make code more concise.  I never thought about the order of precedence within a function call.  I didn’t know that the code inside of a block was equivalent to a single statement.  I didn’t know that you could have an if statement without braces and multiple lines of code below it.  Section 3.3 is a good reminder of the functionality of else-if statements.  I didn’t realise you could have multiple switch expressions execute the same statement(s).  It makes sense now to put a break after the default case (defensive programming).  I didn’t know that the commas separating variable declarations outside of for loops are not the comma operator.  Can you declare two different data types in the first part of a for loop?  Section 3.6 is a good reminder for do-while loops, which can be important.  A good point that a continue inside a while or do will immediately go to the expression and might skip over incrementation.  I had heard of gotos before, but never seen them in code.  I can see their potential use, but I also think that you could accomplish the same functionality using control statements.  What are preprocessor directives in C?  I didn’t know that if the return type is omitted then we assume the function returns an int.  It is interesting that the author decides to mention object files and compilation this early in the book.  I didn’t know that a function is assumed to return an int if it is not declared.  I didn’t know that functions themselves are always external.  But then what about functions defined inside classes?  Section 4.4 is a good reminder that main cannot see external functions and variables below it if they are not declared above main.  But you can use the extern if you are referring to a variable before it is defined.  I didn’t know that the line extern int var; does not set aside storage for var.  It is good to know that array sizes do not need to be specified in extern declaration.  Section 4.5 is a good reminder for why we use header files, since they make it so each .c file only has what it needs.  I didn’t know that static could be used on extern declared variables to be not visible by users of a file.  What is the use of static local variables?  I didn’t know you could declare variables as register that seems very powerful.  Can you modify a static variable?  Section 4.9 is a good reminder that arrays have somewhat strict initialization rules.  How often is recursion used in actual software, since it can occupy a large space and does not speed up runtime?  Do all preprocessor operations start with a #?  I didn’t know a #include could have other #include.  I didn’t know you could define some name as an infinite loop.  What exactly is a macro?  Interesting a macro will work similarly to a templated function.  I didn’t know it was possibly to control the preprocessor itself with conditional inclusion.  Conditional inclusion looks nice because you the program will only define and include files it needs.  I didn’t know that each .c file should have a corresponding .h file (except for the main module).  I didn’t know that a linked file only needs to be compiled once and then every time it is changed.  Good advice to always use “include guard”.  I learned that I should set up program-wide variables with an extern declaration in the header and the definition in the .c.  I learned to not mention variables only used by the .c in the header file.  Forward declarations seem good for decoupling.  In a .c file always include its corresponding header first.I didn’t know a stream is just a sequence of characters with functions to take them out one end and put them in the other.  I didn’t know the streams cin and cout are global variables.  I didn’t know that endl is known as a stream manipulator.  I also didn’t know that it flushes the stream.  I didn’t know there is a flush manipulator.  I didn’t know there is no way to get the >> operator to read the next character regardless of whether it is whitespace or not.  I didn’t know you can use a member function to limit the amount of characters you read in.  I didn’t know the stream input operator fails only if it is unable to find anything at all that satisfies the input request.  I didn’t know the stream state is represented by a number that you can check.  I didn’t know you can clear the stream state with clear().  I didn’t know all of the functions and operators available to ostream and istream are available to the ifstream and ofstream.  I didn’t know closing output files was so important.  I didn’t know that for output if the output file is already there it is deleted and a new blank file is created.  I didn’t know the getline() function will not overflow a string.  I didn’t know that stream objects have a set of internal bits that remember the state of the stream.  I didn’t know a hardware failure sets the bad bit, and an input error sets the fail bit.

## Chapter 5-6

What is the purpose of a pointer to void?  I didn’t know that the & operator can’t apply to expressions, constants, and register variables.  If a pointer holds a memory address why does it matter if that address is for an int or a char?  I learned that pointers are very good if a function needs to modify the values of the caller.  I didn’t know that using pointer arithmetic is faster than using array subscripts.  I didn’t know that the forms of *(a+i) and a[i] are equivalent.  It is interesting that you can use subscripts on a pointer.  If C sees arrays and pointer parameters as equivalent can you do a++ if an array is passed in?  I didn’t know how much went on behind the scenes for allocating memory, for example how allocp is used.  Why is 0 never a valid address for data? Is it used by C  for something?  It is interesting how pointers take into account the size of the data type they are pointing to.  I didn’t know that when you pass string constants to functions it really gets passed as a pointer, which makes sense because you are really just passing an array.  So in the strcpy example the pointers are passed by value so we can modify them without changing the pointers from the caller, but we still change the memory the pointers are looking at, which changes the string contents of s?  I knew you could do an array of pointers, but I was unsure of an application, the pointers to lines of text is a good example.  Can declare functions inside other functions and just not define them?  What is a rectangular multi-dimensional array?  That is are there other kinds of multi-dimensional arrays?  It’s smart to use leap as an indice of the array tab, saves syntax and is representationally clear.  What range of integers can char store?  I didn’t know that the first dimension (subscript) of an array was free.  If the size of the array is not specified the compiler counts the initializers and fills the correct number, is this less efficient than specifying the size? So if we know that the rows of a multi-dimensional array will all be the same length is it always better to use a multi-dimensional array since an array of pointers will need extra memory for the pointers themselves?  I never knew that argv is an array of char pointers.  This clears up things under the hood of command line arguments.  I didn’t know that the format argument for printf could be an expression too.  I didn’t know that it was possible to define pointers to functions.  I didn’t know that when casting a pointer to void no information is lost.  So custom comparators are pointers to functions?  Is this section talking about how C parses our syntax?  What happens if you don’t use a structure tag?  How would you call and initialize the structure’s data?  I didn’t realize you could follow a struct by a list of variables like you can do with ints and other data types.  What is the difference between a structure and an automatic structure?  Structures may not be compared, but can you compare variables that are the same structure?  How does the memory for structs work?  Is the memory contiguous like an array?  Section 6.3 is a good example of how we should make closely related data into a struct.  I didn’t know that the sizeof can not be used in the preprocessor because the preprocessor does not parse type names.  Why are #define expressions not evaluated in the preprocessor?  I thought they were.  Why can we subtract two pointers, but not add them?  It is interesting that the sizeof operator takes into account structure padding.  I didn’t realize that a binary tree was a self referential struct.  What does copying a string into a safe place mean exactly?  Section 6.6 goes over the underlying ways of how symbols and values are mapped together that I was oblivious to previously.  I didn’t know that you could make your own custom types with typedef.  What are portability problems?  How is a union different than a struct?  Wow it seems powerful to be able to hold various data types in one variable.  Bit fields seem good when you do not have a lot of memory, but they seem rigid since fields are machine dependent.

## Chapter 7

It seems powerful that reading input and producing output is independent from whatever the command line is doing, piping, etc.  It also never occurred to me how much I take for granted that when I transfer C code to any computer that can compile C, the code works.  How does the fact that some functions are often macros and avoid the overhead of a function call?  I didn’t know how many different formatting options there were with printf.  I didn’t know that … in a function means that the number and types of arguments may vary.  I didn’t know that the declaration … can only appear at the end of an argument list.  I didn’t know that scanf returns as its value the number of successfully matched and assigned input items.  I didn’t know that you could suppress input assignment.  I didn’t know that scanf only took pointers as arguments.  I didn’t know that scanf ignores blanks and tabs in its format string.  Does reading a line at a time and then picking apart the input with sscanf take longer than just using scanf?  It makes sense that a file has to be opened before it is read or written.  I didn’t know that fopen returns a pointer with a lot of information about the file.  What is the difference between append and write?  I didn’t know that if a file that doesn’t exist is opened for writing or appending then it is created if possible.  I didn’t know that opening a file for writing erases the previous contents.  I didn’t know that standard input, standard output, and standard error are files with file pointers.  I didn’t realize the reason it is good to close files after use is we have a finite number of files able to be open simultaneously.  I didn’t know that fclose flushed the buffer or that fclose is automatically called for each open file when a program terminates.  I didn’t know that you can close stdin and stdout.  I didn’t know that exit calls fclose for each open output file.  It is weird that gets deletes the terminal \n and puts adds it.  Why would we use fgets or gets instead of getline?  Does strncat concatenate the first n characters of t to end of s?  I didn’t know a function like system existed where you can execute commands from your code.  So the memory allocated by malloc is not contiguous and calloc is?  What happens if you try to free memory that was not obtained by malloc or calloc?  The handout cleared up to me why we need the format string in C so when printing we know how to output the binary representation that we have.  I didn’t know that the … declaration works by pushing the arguments onto the function call stack followed by a copy of the argument values.  The handout also clears up why you need to have the format arguments in the correct order, otherwise you just end up with bits representing gibberish.  I didn’t know that for doubles up to 6 digits counted left and right of the decimal are used by default in printf.  I didn’t know that the reason output buffers are used is because output hardware is much slower compared to CPU speeds.  I didn’t know that stderr is not buffered.  I didn’t even think about how we are able to delete input to our program before pressing the carriage return.  When characters are removed from the stream where do they go?  If scanf has a %d and is reading in a decimal integer until there is a character that can’t be part of a decimal integer would a scan of 12.3 just scan the 12 and take that?  I didn’t know that when scanning you can specify the maximum number of characters to read into a string.  I learned to not test stdin for EOF.  I learned to not try to modify the members of FILE.  I learned it is important to close output files so all of the buffer is outputted.  I learned that it is better to control a loop by testing for a successful read.
